/*
 * j2eetraining.test.calc.Calc 0.1, 18/02/07
 *
 * (C) Copyright Dmitry Chuchva, 2007 
 */

package j2eetraining.tests.calc;

import java.util.*;
import java.io.*;
import antlr.*;

/**
 * Main application class.
 * 
 * This class manages user input and trasfers it to ANTLR generated parser. Class also 
 * does most exception handling and prints error messages in user-oriented form. <br>Execution
 * starts with main function, and first of all method {@link loadConfig} is called. This
 * method tries to dynamically load compiled classes by their names, listed in special 
 * configuration file. Classes, that a valid for this application, must be extended from
 * special defined "framework" classes {@link Element}, {@link Constant} and {@link Function}.
 * This mechanism allows to extend functionality of our calculator by adding new functions
 * and constants. This mades this calculator very flexible and powerfull.<br>
 * Than, in cycle, application requests an input string for evaluating, and parses it with
 * automatically generated by ANTLR tool parser&lexer. Sematic actions of grammar, described
 * in file Calc.g do an evaluation of result, and also it's output. So, after call to parser,
 * we are ready for new input. Application terminates, when method readLine() of class {@link 
 * Console} returns null, for example, when user presses Ctrl-C. 
 *  
 */
public final class Calc {
	
	/**
	 * String, which contains configuration file name.
	 * From file with this name application loads class names.
	 */
	public static final String configFile = "calc.properties";
	
	/**
	 * TreeMap, which contains objects representing functions and constants of calculator.
	 * {@link TreeMap} is used to quickly find necessary object (function or constant) by it's name.
	 * Name is of type String and is a key of map.   
	 */
	private static Map<String, Element> elems = new TreeMap<String, Element>();

	/**
	 * Main method of application.
	 * From this point starts application execution process.
	 * @param args command line arguments for process, not used here
	 */
	public static void main(String[] args) {
		System.out.println("Calculator ver.0.1a, (c) Dmitry Chuchva, 2007");
		if (!loadConfig(configFile)) {
			System.out.println("warning: unable to load config file '" + configFile + "', continuing without functions and constants...");			
		}
		
		while (true) {
			try {
				String str;
				str = System.console().readLine();
				if (str == null) {
					break;
				}
				if (str.equals("")) {
					continue;
				}
				str = str + "\n";
				CalcLexer lexer = new CalcLexer(new StringReader(str));
				CalcParser parser = new CalcParser(lexer);
				// call root "line" rule, which represents all possible chains of our math language  
				parser.line();
			}
			// some exceptions throwed by parser
			catch (TokenStreamException e) {
				System.out.println(e.getMessage());
			}
			catch (RecognitionException e) {
				String s = e.getMessage().replace("\n","EOL");
				System.out.println(s);
			}
			// our exception, represents general calculator error
			catch (CalcException e) {
				System.out.println(e.getMessage());
			}
		}
	}
	
	/**
	 * Loads classes of functions and constants.
	 * This method parses configuration file contents and loads specified there
	 * classes with help of class {@link ClassLoader}. Objects of loaded classes are
	 * stored in "elems" map. For parsing of configuration file used class {@link Properties}.
	 * If two classes were identified with one name, only the latest loaded class will be available 
	 * (as it is defined by put method of {@link TreeMap}).  
	 * @param name configuration file name
	 * @return true, if configuration file exists, false, if no
	 */
	public static boolean loadConfig(String name) {
		Properties props = new Properties();
		FileReader reader = null;
		
		try {
			reader = new FileReader(name);
			props.load(reader);			
		}
		catch (FileNotFoundException e) {
			return false;
		}
		catch (IOException e) {
			return false;
		}
	
		ClassLoader loader = ClassLoader.getSystemClassLoader();
		for (Enumeration en = props.propertyNames(); en.hasMoreElements();) {
			String id = (String)en.nextElement();
			Element el = null;
			try {
				el = (Element)loader.loadClass(props.getProperty(id)).newInstance();
			} catch (ClassNotFoundException e) {
				System.out.println("warning: implementation of " + id + " not found, ignored...");
			} catch (InstantiationException e) {
				System.out.println("warning: error occured while loading of " + id);
			} catch (IllegalAccessException e) {
				System.out.println("warning: error occured while loading of " + id);
			} catch (ClassCastException e) {
				System.out.println("warning: " + id + " is not a subclass of Element, ignored...");
			} finally {
				if (el != null) {
					elems.put(id,el);
				}
			}
		}
		
		try {
			reader.close();
		} catch (IOException e) {
		}
		return true;
	}
	
	/**
	 * Tests, if specified identificator is a name of existing function. 
	 * @param id string representation of function name
	 * @return true, in case of existing of function with specified id, or false, in other cases 
	 */
	public static boolean isFunction(String id) {
		if (elems.containsKey(id)) {
			Element el = elems.get(id);
			if (el.getType() == Element.FUNCTION) {
				return true;
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
	
	/**
	 * Returns value of constant with specified name.
	 * Searches thru our map with existing functions and constans. If found, tests, if
	 * type of element is "constant" type, and if so, calls it's method value(), which
	 * returns a value, representing this constant. In other cases, generates errors, or
	 * returns 0 when it is possible to continue normal parsing.
	 * @param id name of element, found in input string by parser&lexer
	 * @return value of constant with specified name
	 * @throws CalcException in cases of errors
	 */
	public static double valueOf(String id) throws CalcException {
		if (elems.containsKey(id)) {
			Element el = elems.get(id);
			if (el.getType() == Element.CONSTANT) {
				try {
					Constant c = (Constant)el;
					return c.value();
				}
				catch (ClassCastException e) {
					throw new CalcException("error: bad class \"" + id + "\"");					
				}
			}
			else {
				if (el.getType() != Element.FUNCTION) {
					throw new CalcException("error: bad class \"" + id + "\"");
				} else {
					return 0.0;
				}
			}
		} else {
			throw new CalcException("error: cannot resolve symbol \"" + id + "\"");
		}
	}
	
	/**
	 * Returns value of function with specified name and arguments.
	 * Searches thru our map with existing functions and constans. If found, tests, if
	 * type of element is "function" type, and if so, calls it's method call() with arguments,
	 * which returns a value of this function. In other cases, generates errors (such as missing
	 * arguments etc.).
	 * <br>This method also processes cases when function has variable count of arguments.
	 * @param id name of element, found in input string by parser&lexer
	 * @param args arguments for function parsed from input string
	 * @return value of function
	 * @throws CalcException in cases of errors
	 */
	public static double callOf(String id, Vector args) throws CalcException {
		if (elems.containsKey(id)) {
			Element el = elems.get(id);
			if (el.getType() == Element.FUNCTION) {
				Function f = (Function)el;
				if (f.getArgumentsCount() == Function.VARIABLE || 
					f.getArgumentsCount() == args.size()) {
					double[] dargs = new double[args.size()];
					for (int i = 0; i < args.size(); i++) {
						Double val = (Double)args.get(i);
						dargs[i] = val.doubleValue();						
					}
					return f.call(dargs);
				}
				else {
					if (f.getArgumentsCount() == Function.VARIABLE) {
						throw new CalcException("error: function \"" + id + "\" takes at least 1 parameter");						
					} else {
						throw new CalcException("error: function \"" + id + "\" takes " + f.getArgumentsCount() + " parameter(s)");
					}
				}
			}
			else {
				if (el.getType() == Element.CONSTANT) {
					throw new CalcException("error: \"" + id + "\" is a constant");
				}
				else {
					throw new CalcException("error: bad class \"" + id + "\"");
				}
			}
		} else {
			throw new CalcException("error: cannot resolve symbol \"" + id + "\"");
		}
	}
}